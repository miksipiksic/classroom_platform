{"ast":null,"code":"// Copyright 2017 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/vm200325d/Documents/faks/pia/pia_projekat/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst childProcess = require('child_process');\nconst {\n  isLinux,\n  getReport\n} = require('./process');\nconst {\n  LDD_PATH,\n  readFile,\n  readFileSync\n} = require('./filesystem');\nlet cachedFamilyFilesystem;\nlet cachedVersionFilesystem;\nconst command = 'getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true';\nlet commandOut = '';\nconst safeCommand = () => {\n  if (!commandOut) {\n    return new Promise(resolve => {\n      childProcess.exec(command, (err, out) => {\n        commandOut = err ? ' ' : out;\n        resolve(commandOut);\n      });\n    });\n  }\n  return commandOut;\n};\nconst safeCommandSync = () => {\n  if (!commandOut) {\n    try {\n      commandOut = childProcess.execSync(command, {\n        encoding: 'utf8'\n      });\n    } catch (_err) {\n      commandOut = ' ';\n    }\n  }\n  return commandOut;\n};\n\n/**\n * A String constant containing the value `glibc`.\n * @type {string}\n * @public\n */\nconst GLIBC = 'glibc';\n\n/**\n * A Regexp constant to get the GLIBC Version.\n * @type {string}\n */\nconst RE_GLIBC_VERSION = /GLIBC\\s(\\d+\\.\\d+)/;\n\n/**\n * A String constant containing the value `musl`.\n * @type {string}\n * @public\n */\nconst MUSL = 'musl';\n\n/**\n * This string is used to find if the {@link LDD_PATH} is GLIBC\n * @type {string}\n */\nconst GLIBC_ON_LDD = GLIBC.toUpperCase();\n\n/**\n * This string is used to find if the {@link LDD_PATH} is musl\n * @type {string}\n */\nconst MUSL_ON_LDD = MUSL.toLowerCase();\nconst isFileMusl = f => f.includes('libc.musl-') || f.includes('ld-musl-');\nconst familyFromReport = () => {\n  const report = getReport();\n  if (report.header && report.header.glibcVersionRuntime) {\n    return GLIBC;\n  }\n  if (Array.isArray(report.sharedObjects)) {\n    if (report.sharedObjects.some(isFileMusl)) {\n      return MUSL;\n    }\n  }\n  return null;\n};\nconst familyFromCommand = out => {\n  const [getconf, ldd1] = out.split(/[\\r\\n]+/);\n  if (getconf && getconf.includes(GLIBC)) {\n    return GLIBC;\n  }\n  if (ldd1 && ldd1.includes(MUSL)) {\n    return MUSL;\n  }\n  return null;\n};\nconst getFamilyFromLddContent = content => {\n  if (content.includes(MUSL_ON_LDD)) {\n    return MUSL;\n  }\n  if (content.includes(GLIBC_ON_LDD)) {\n    return GLIBC;\n  }\n  return null;\n};\nconst familyFromFilesystem = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* () {\n    if (cachedFamilyFilesystem !== undefined) {\n      return cachedFamilyFilesystem;\n    }\n    cachedFamilyFilesystem = null;\n    try {\n      const lddContent = yield readFile(LDD_PATH);\n      cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);\n    } catch (e) {}\n    return cachedFamilyFilesystem;\n  });\n  return function familyFromFilesystem() {\n    return _ref.apply(this, arguments);\n  };\n}();\nconst familyFromFilesystemSync = () => {\n  if (cachedFamilyFilesystem !== undefined) {\n    return cachedFamilyFilesystem;\n  }\n  cachedFamilyFilesystem = null;\n  try {\n    const lddContent = readFileSync(LDD_PATH);\n    cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);\n  } catch (e) {}\n  return cachedFamilyFilesystem;\n};\n\n/**\n * Resolves with the libc family when it can be determined, `null` otherwise.\n * @returns {Promise<?string>}\n */\nconst family = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* () {\n    let family = null;\n    if (isLinux()) {\n      family = yield familyFromFilesystem();\n      if (!family) {\n        family = familyFromReport();\n      }\n      if (!family) {\n        const out = yield safeCommand();\n        family = familyFromCommand(out);\n      }\n    }\n    return family;\n  });\n  return function family() {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n/**\n * Returns the libc family when it can be determined, `null` otherwise.\n * @returns {?string}\n */\nconst familySync = () => {\n  let family = null;\n  if (isLinux()) {\n    family = familyFromFilesystemSync();\n    if (!family) {\n      family = familyFromReport();\n    }\n    if (!family) {\n      const out = safeCommandSync();\n      family = familyFromCommand(out);\n    }\n  }\n  return family;\n};\n\n/**\n * Resolves `true` only when the platform is Linux and the libc family is not `glibc`.\n * @returns {Promise<boolean>}\n */\nconst isNonGlibcLinux = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* () {\n    return isLinux() && (yield family()) !== GLIBC;\n  });\n  return function isNonGlibcLinux() {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\n/**\n * Returns `true` only when the platform is Linux and the libc family is not `glibc`.\n * @returns {boolean}\n */\nconst isNonGlibcLinuxSync = () => isLinux() && familySync() !== GLIBC;\nconst versionFromFilesystem = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* () {\n    if (cachedVersionFilesystem !== undefined) {\n      return cachedVersionFilesystem;\n    }\n    cachedVersionFilesystem = null;\n    try {\n      const lddContent = yield readFile(LDD_PATH);\n      const versionMatch = lddContent.match(RE_GLIBC_VERSION);\n      if (versionMatch) {\n        cachedVersionFilesystem = versionMatch[1];\n      }\n    } catch (e) {}\n    return cachedVersionFilesystem;\n  });\n  return function versionFromFilesystem() {\n    return _ref4.apply(this, arguments);\n  };\n}();\nconst versionFromFilesystemSync = () => {\n  if (cachedVersionFilesystem !== undefined) {\n    return cachedVersionFilesystem;\n  }\n  cachedVersionFilesystem = null;\n  try {\n    const lddContent = readFileSync(LDD_PATH);\n    const versionMatch = lddContent.match(RE_GLIBC_VERSION);\n    if (versionMatch) {\n      cachedVersionFilesystem = versionMatch[1];\n    }\n  } catch (e) {}\n  return cachedVersionFilesystem;\n};\nconst versionFromReport = () => {\n  const report = getReport();\n  if (report.header && report.header.glibcVersionRuntime) {\n    return report.header.glibcVersionRuntime;\n  }\n  return null;\n};\nconst versionSuffix = s => s.trim().split(/\\s+/)[1];\nconst versionFromCommand = out => {\n  const [getconf, ldd1, ldd2] = out.split(/[\\r\\n]+/);\n  if (getconf && getconf.includes(GLIBC)) {\n    return versionSuffix(getconf);\n  }\n  if (ldd1 && ldd2 && ldd1.includes(MUSL)) {\n    return versionSuffix(ldd2);\n  }\n  return null;\n};\n\n/**\n * Resolves with the libc version when it can be determined, `null` otherwise.\n * @returns {Promise<?string>}\n */\nconst version = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator(function* () {\n    let version = null;\n    if (isLinux()) {\n      version = yield versionFromFilesystem();\n      if (!version) {\n        version = versionFromReport();\n      }\n      if (!version) {\n        const out = yield safeCommand();\n        version = versionFromCommand(out);\n      }\n    }\n    return version;\n  });\n  return function version() {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\n/**\n * Returns the libc version when it can be determined, `null` otherwise.\n * @returns {?string}\n */\nconst versionSync = () => {\n  let version = null;\n  if (isLinux()) {\n    version = versionFromFilesystemSync();\n    if (!version) {\n      version = versionFromReport();\n    }\n    if (!version) {\n      const out = safeCommandSync();\n      version = versionFromCommand(out);\n    }\n  }\n  return version;\n};\nmodule.exports = {\n  GLIBC,\n  MUSL,\n  family,\n  familySync,\n  isNonGlibcLinux,\n  isNonGlibcLinuxSync,\n  version,\n  versionSync\n};","map":{"version":3,"names":["_asyncToGenerator","require","default","childProcess","isLinux","getReport","LDD_PATH","readFile","readFileSync","cachedFamilyFilesystem","cachedVersionFilesystem","command","commandOut","safeCommand","Promise","resolve","exec","err","out","safeCommandSync","execSync","encoding","_err","GLIBC","RE_GLIBC_VERSION","MUSL","GLIBC_ON_LDD","toUpperCase","MUSL_ON_LDD","toLowerCase","isFileMusl","f","includes","familyFromReport","report","header","glibcVersionRuntime","Array","isArray","sharedObjects","some","familyFromCommand","getconf","ldd1","split","getFamilyFromLddContent","content","familyFromFilesystem","_ref","undefined","lddContent","e","apply","arguments","familyFromFilesystemSync","family","_ref2","familySync","isNonGlibcLinux","_ref3","isNonGlibcLinuxSync","versionFromFilesystem","_ref4","versionMatch","match","versionFromFilesystemSync","versionFromReport","versionSuffix","s","trim","versionFromCommand","ldd2","version","_ref5","versionSync","module","exports"],"sources":["C:/Users/vm200325d/Documents/faks/pia/pia_projekat/frontend/node_modules/detect-libc/lib/detect-libc.js"],"sourcesContent":["// Copyright 2017 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst childProcess = require('child_process');\nconst { isLinux, getReport } = require('./process');\nconst { LDD_PATH, readFile, readFileSync } = require('./filesystem');\n\nlet cachedFamilyFilesystem;\nlet cachedVersionFilesystem;\n\nconst command = 'getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true';\nlet commandOut = '';\n\nconst safeCommand = () => {\n  if (!commandOut) {\n    return new Promise((resolve) => {\n      childProcess.exec(command, (err, out) => {\n        commandOut = err ? ' ' : out;\n        resolve(commandOut);\n      });\n    });\n  }\n  return commandOut;\n};\n\nconst safeCommandSync = () => {\n  if (!commandOut) {\n    try {\n      commandOut = childProcess.execSync(command, { encoding: 'utf8' });\n    } catch (_err) {\n      commandOut = ' ';\n    }\n  }\n  return commandOut;\n};\n\n/**\n * A String constant containing the value `glibc`.\n * @type {string}\n * @public\n */\nconst GLIBC = 'glibc';\n\n/**\n * A Regexp constant to get the GLIBC Version.\n * @type {string}\n */\nconst RE_GLIBC_VERSION = /GLIBC\\s(\\d+\\.\\d+)/;\n\n/**\n * A String constant containing the value `musl`.\n * @type {string}\n * @public\n */\nconst MUSL = 'musl';\n\n/**\n * This string is used to find if the {@link LDD_PATH} is GLIBC\n * @type {string}\n */\nconst GLIBC_ON_LDD = GLIBC.toUpperCase();\n\n/**\n * This string is used to find if the {@link LDD_PATH} is musl\n * @type {string}\n */\nconst MUSL_ON_LDD = MUSL.toLowerCase();\n\nconst isFileMusl = (f) => f.includes('libc.musl-') || f.includes('ld-musl-');\n\nconst familyFromReport = () => {\n  const report = getReport();\n  if (report.header && report.header.glibcVersionRuntime) {\n    return GLIBC;\n  }\n  if (Array.isArray(report.sharedObjects)) {\n    if (report.sharedObjects.some(isFileMusl)) {\n      return MUSL;\n    }\n  }\n  return null;\n};\n\nconst familyFromCommand = (out) => {\n  const [getconf, ldd1] = out.split(/[\\r\\n]+/);\n  if (getconf && getconf.includes(GLIBC)) {\n    return GLIBC;\n  }\n  if (ldd1 && ldd1.includes(MUSL)) {\n    return MUSL;\n  }\n  return null;\n};\n\nconst getFamilyFromLddContent = (content) => {\n  if (content.includes(MUSL_ON_LDD)) {\n    return MUSL;\n  }\n  if (content.includes(GLIBC_ON_LDD)) {\n    return GLIBC;\n  }\n  return null;\n};\n\nconst familyFromFilesystem = async () => {\n  if (cachedFamilyFilesystem !== undefined) {\n    return cachedFamilyFilesystem;\n  }\n  cachedFamilyFilesystem = null;\n  try {\n    const lddContent = await readFile(LDD_PATH);\n    cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);\n  } catch (e) {}\n  return cachedFamilyFilesystem;\n};\n\nconst familyFromFilesystemSync = () => {\n  if (cachedFamilyFilesystem !== undefined) {\n    return cachedFamilyFilesystem;\n  }\n  cachedFamilyFilesystem = null;\n  try {\n    const lddContent = readFileSync(LDD_PATH);\n    cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);\n  } catch (e) {}\n  return cachedFamilyFilesystem;\n};\n\n/**\n * Resolves with the libc family when it can be determined, `null` otherwise.\n * @returns {Promise<?string>}\n */\nconst family = async () => {\n  let family = null;\n  if (isLinux()) {\n    family = await familyFromFilesystem();\n    if (!family) {\n      family = familyFromReport();\n    }\n    if (!family) {\n      const out = await safeCommand();\n      family = familyFromCommand(out);\n    }\n  }\n  return family;\n};\n\n/**\n * Returns the libc family when it can be determined, `null` otherwise.\n * @returns {?string}\n */\nconst familySync = () => {\n  let family = null;\n  if (isLinux()) {\n    family = familyFromFilesystemSync();\n    if (!family) {\n      family = familyFromReport();\n    }\n    if (!family) {\n      const out = safeCommandSync();\n      family = familyFromCommand(out);\n    }\n  }\n  return family;\n};\n\n/**\n * Resolves `true` only when the platform is Linux and the libc family is not `glibc`.\n * @returns {Promise<boolean>}\n */\nconst isNonGlibcLinux = async () => isLinux() && await family() !== GLIBC;\n\n/**\n * Returns `true` only when the platform is Linux and the libc family is not `glibc`.\n * @returns {boolean}\n */\nconst isNonGlibcLinuxSync = () => isLinux() && familySync() !== GLIBC;\n\nconst versionFromFilesystem = async () => {\n  if (cachedVersionFilesystem !== undefined) {\n    return cachedVersionFilesystem;\n  }\n  cachedVersionFilesystem = null;\n  try {\n    const lddContent = await readFile(LDD_PATH);\n    const versionMatch = lddContent.match(RE_GLIBC_VERSION);\n    if (versionMatch) {\n      cachedVersionFilesystem = versionMatch[1];\n    }\n  } catch (e) {}\n  return cachedVersionFilesystem;\n};\n\nconst versionFromFilesystemSync = () => {\n  if (cachedVersionFilesystem !== undefined) {\n    return cachedVersionFilesystem;\n  }\n  cachedVersionFilesystem = null;\n  try {\n    const lddContent = readFileSync(LDD_PATH);\n    const versionMatch = lddContent.match(RE_GLIBC_VERSION);\n    if (versionMatch) {\n      cachedVersionFilesystem = versionMatch[1];\n    }\n  } catch (e) {}\n  return cachedVersionFilesystem;\n};\n\nconst versionFromReport = () => {\n  const report = getReport();\n  if (report.header && report.header.glibcVersionRuntime) {\n    return report.header.glibcVersionRuntime;\n  }\n  return null;\n};\n\nconst versionSuffix = (s) => s.trim().split(/\\s+/)[1];\n\nconst versionFromCommand = (out) => {\n  const [getconf, ldd1, ldd2] = out.split(/[\\r\\n]+/);\n  if (getconf && getconf.includes(GLIBC)) {\n    return versionSuffix(getconf);\n  }\n  if (ldd1 && ldd2 && ldd1.includes(MUSL)) {\n    return versionSuffix(ldd2);\n  }\n  return null;\n};\n\n/**\n * Resolves with the libc version when it can be determined, `null` otherwise.\n * @returns {Promise<?string>}\n */\nconst version = async () => {\n  let version = null;\n  if (isLinux()) {\n    version = await versionFromFilesystem();\n    if (!version) {\n      version = versionFromReport();\n    }\n    if (!version) {\n      const out = await safeCommand();\n      version = versionFromCommand(out);\n    }\n  }\n  return version;\n};\n\n/**\n * Returns the libc version when it can be determined, `null` otherwise.\n * @returns {?string}\n */\nconst versionSync = () => {\n  let version = null;\n  if (isLinux()) {\n    version = versionFromFilesystemSync();\n    if (!version) {\n      version = versionFromReport();\n    }\n    if (!version) {\n      const out = safeCommandSync();\n      version = versionFromCommand(out);\n    }\n  }\n  return version;\n};\n\nmodule.exports = {\n  GLIBC,\n  MUSL,\n  family,\n  familySync,\n  isNonGlibcLinux,\n  isNonGlibcLinuxSync,\n  version,\n  versionSync\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}