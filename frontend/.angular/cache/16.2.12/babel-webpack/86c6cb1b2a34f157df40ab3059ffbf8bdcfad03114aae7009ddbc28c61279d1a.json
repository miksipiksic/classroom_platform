{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/vm200325d/Documents/faks/pia/pia_projekat/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst fs = require('graceful-fs');\nconst os = require('os');\nconst {\n  backOff\n} = require('exponential-backoff');\nconst rm = require('rimraf');\nconst tar = require('tar');\nconst path = require('path');\nconst util = require('util');\nconst stream = require('stream');\nconst crypto = require('crypto');\nconst log = require('npmlog');\nconst semver = require('semver');\nconst fetch = require('make-fetch-happen');\nconst processRelease = require('./process-release');\nconst win = process.platform === 'win32';\nconst streamPipeline = util.promisify(stream.pipeline);\n\n/**\n * @param {typeof import('graceful-fs')} fs\n */\nfunction install(_x, _x2, _x3) {\n  return _install.apply(this, arguments);\n}\nfunction _install() {\n  _install = _asyncToGenerator(function* (fs, gyp, argv) {\n    const release = processRelease(argv, gyp, process.version, process.release);\n    // Detecting target_arch based on logic from create-cnfig-gyp.js. Used on Windows only.\n    const arch = win ? gyp.opts.target_arch || gyp.opts.arch || process.arch || 'ia32' : '';\n    // Used to prevent downloading tarball if only new node.lib is required on Windows.\n    let shouldDownloadTarball = true;\n\n    // Determine which node dev files version we are installing\n    log.verbose('install', 'input version string %j', release.version);\n    if (!release.semver) {\n      // could not parse the version string with semver\n      throw new Error('Invalid version number: ' + release.version);\n    }\n    if (semver.lt(release.version, '0.8.0')) {\n      throw new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version);\n    }\n\n    // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n    if (release.semver.prerelease[0] === 'pre') {\n      log.verbose('detected \"pre\" node version', release.version);\n      if (!gyp.opts.nodedir) {\n        throw new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead');\n      }\n      log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir);\n      return;\n    }\n\n    // flatten version into String\n    log.verbose('install', 'installing version: %s', release.versionDir);\n\n    // the directory where the dev files will be installed\n    const devDir = path.resolve(gyp.devDir, release.versionDir);\n\n    // If '--ensure' was passed, then don't *always* install the version;\n    // check if it is already installed, and only install when needed\n    if (gyp.opts.ensure) {\n      log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed');\n      try {\n        yield fs.promises.stat(devDir);\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          log.verbose('install', 'version not already installed, continuing with install', release.version);\n          try {\n            return yield go();\n          } catch (err) {\n            return rollback(err);\n          }\n        } else if (err.code === 'EACCES') {\n          return eaccesFallback(err);\n        }\n        throw err;\n      }\n      log.verbose('install', 'version is already installed, need to check \"installVersion\"');\n      const installVersionFile = path.resolve(devDir, 'installVersion');\n      let installVersion = 0;\n      try {\n        const ver = yield fs.promises.readFile(installVersionFile, 'ascii');\n        installVersion = parseInt(ver, 10) || 0;\n      } catch (err) {\n        if (err.code !== 'ENOENT') {\n          throw err;\n        }\n      }\n      log.verbose('got \"installVersion\"', installVersion);\n      log.verbose('needs \"installVersion\"', gyp.package.installVersion);\n      if (installVersion < gyp.package.installVersion) {\n        log.verbose('install', 'version is no good; reinstalling');\n        try {\n          return yield go();\n        } catch (err) {\n          return rollback(err);\n        }\n      }\n      log.verbose('install', 'version is good');\n      if (win) {\n        log.verbose('on Windows; need to check node.lib');\n        const nodeLibPath = path.resolve(devDir, arch, 'node.lib');\n        try {\n          yield fs.promises.stat(nodeLibPath);\n        } catch (err) {\n          if (err.code === 'ENOENT') {\n            log.verbose('install', `version not already installed for ${arch}, continuing with install`, release.version);\n            try {\n              shouldDownloadTarball = false;\n              return yield go();\n            } catch (err) {\n              return rollback(err);\n            }\n          } else if (err.code === 'EACCES') {\n            return eaccesFallback(err);\n          }\n          throw err;\n        }\n      }\n    } else {\n      try {\n        return yield go();\n      } catch (err) {\n        return rollback(err);\n      }\n    }\n    function copyDirectory(_x7, _x8) {\n      return _copyDirectory.apply(this, arguments);\n    }\n    function _copyDirectory() {\n      _copyDirectory = _asyncToGenerator(function* (src, dest) {\n        try {\n          yield fs.promises.stat(src);\n        } catch {\n          throw new Error(`Missing source directory for copy: ${src}`);\n        }\n        yield fs.promises.mkdir(dest, {\n          recursive: true\n        });\n        const entries = yield fs.promises.readdir(src, {\n          withFileTypes: true\n        });\n        for (const entry of entries) {\n          if (entry.isDirectory()) {\n            yield copyDirectory(path.join(src, entry.name), path.join(dest, entry.name));\n          } else if (entry.isFile()) {\n            // with parallel installs, copying files may cause file errors on\n            // Windows so use an exponential backoff to resolve collisions\n            yield backOff( /*#__PURE__*/_asyncToGenerator(function* () {\n              try {\n                yield fs.promises.copyFile(path.join(src, entry.name), path.join(dest, entry.name));\n              } catch (err) {\n                // if ensure, check if file already exists and that's good enough\n                if (gyp.opts.ensure && err.code === 'EBUSY') {\n                  try {\n                    yield fs.promises.stat(path.join(dest, entry.name));\n                    return;\n                  } catch {}\n                }\n                throw err;\n              }\n            }));\n          } else {\n            throw new Error('Unexpected file directory entry type');\n          }\n        }\n      });\n      return _copyDirectory.apply(this, arguments);\n    }\n    function go() {\n      return _go.apply(this, arguments);\n    } // go()\n    /**\n     * Checks if a given filename is \"valid\" for this installation.\n     */\n    function _go() {\n      _go = _asyncToGenerator(function* () {\n        log.verbose('ensuring devDir is created', devDir);\n\n        // first create the dir for the node dev files\n        try {\n          const created = yield fs.promises.mkdir(devDir, {\n            recursive: true\n          });\n          if (created) {\n            log.verbose('created devDir', created);\n          }\n        } catch (err) {\n          if (err.code === 'EACCES') {\n            return eaccesFallback(err);\n          }\n          throw err;\n        }\n\n        // now download the node tarball\n        const tarPath = gyp.opts.tarball;\n        let extractErrors = false;\n        let extractCount = 0;\n        const contentShasums = {};\n        const expectShasums = {};\n\n        // checks if a file to be extracted from the tarball is valid.\n        // only .h header files and the gyp files get extracted\n        function isValid(path) {\n          const isValid = valid(path);\n          if (isValid) {\n            log.verbose('extracted file from tarball', path);\n            extractCount++;\n          } else {\n            // invalid\n            log.silly('ignoring from tarball', path);\n          }\n          return isValid;\n        }\n        function onwarn(code, message) {\n          extractErrors = true;\n          log.error('error while extracting tarball', code, message);\n        }\n\n        // download the tarball and extract!\n        // Ommited on Windows if only new node.lib is required\n\n        // on Windows there can be file errors from tar if parallel installs\n        // are happening (not uncommon with multiple native modules) so\n        // extract the tarball to a temp directory first and then copy over\n        const tarExtractDir = win ? yield fs.promises.mkdtemp(path.join(os.tmpdir(), 'node-gyp-tmp-')) : devDir;\n        try {\n          if (shouldDownloadTarball) {\n            if (tarPath) {\n              yield tar.extract({\n                file: tarPath,\n                strip: 1,\n                filter: isValid,\n                onwarn,\n                cwd: tarExtractDir\n              });\n            } else {\n              try {\n                const res = yield download(gyp, release.tarballUrl);\n                if (res.status !== 200) {\n                  throw new Error(`${res.status} response downloading ${release.tarballUrl}`);\n                }\n                yield streamPipeline(res.body,\n                // content checksum\n                new ShaSum((_, checksum) => {\n                  const filename = path.basename(release.tarballUrl).trim();\n                  contentShasums[filename] = checksum;\n                  log.verbose('content checksum', filename, checksum);\n                }), tar.extract({\n                  strip: 1,\n                  cwd: tarExtractDir,\n                  filter: isValid,\n                  onwarn\n                }));\n              } catch (err) {\n                // something went wrong downloading the tarball?\n                if (err.code === 'ENOTFOUND') {\n                  throw new Error('This is most likely not a problem with node-gyp or the package itself and\\n' + 'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' + 'network settings.');\n                }\n                throw err;\n              }\n            }\n\n            // invoked after the tarball has finished being extracted\n            if (extractErrors || extractCount === 0) {\n              throw new Error('There was a fatal problem while downloading/extracting the tarball');\n            }\n            log.verbose('tarball', 'done parsing tarball');\n          }\n          const installVersionPath = path.resolve(tarExtractDir, 'installVersion');\n          yield Promise.all([\n          // need to download node.lib\n          ...(win ? [downloadNodeLib()] : []),\n          // write the \"installVersion\" file\n          fs.promises.writeFile(installVersionPath, gyp.package.installVersion + '\\n'),\n          // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n          ...(!tarPath || win ? [downloadShasums()] : [])]);\n          log.verbose('download contents checksum', JSON.stringify(contentShasums));\n          // check content shasums\n          for (const k in contentShasums) {\n            log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k]);\n            if (contentShasums[k] !== expectShasums[k]) {\n              throw new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]);\n            }\n          }\n\n          // copy over the files from the temp tarball extract directory to devDir\n          if (tarExtractDir !== devDir) {\n            yield copyDirectory(tarExtractDir, devDir);\n          }\n        } finally {\n          if (tarExtractDir !== devDir) {\n            try {\n              // try to cleanup temp dir\n              yield util.promisify(rm)(tarExtractDir);\n            } catch {\n              log.warn('failed to clean up temp tarball extract directory');\n            }\n          }\n        }\n        function downloadShasums() {\n          return _downloadShasums.apply(this, arguments);\n        }\n        function _downloadShasums() {\n          _downloadShasums = _asyncToGenerator(function* () {\n            log.verbose('check download content checksum, need to download `SHASUMS256.txt`...');\n            log.verbose('checksum url', release.shasumsUrl);\n            const res = yield download(gyp, release.shasumsUrl);\n            if (res.status !== 200) {\n              throw new Error(`${res.status}  status code downloading checksum`);\n            }\n            for (const line of (yield res.text()).trim().split('\\n')) {\n              const items = line.trim().split(/\\s+/);\n              if (items.length !== 2) {\n                return;\n              }\n\n              // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n              const name = items[1].replace(/^\\.\\//, '');\n              expectShasums[name] = items[0];\n            }\n            log.verbose('checksum data', JSON.stringify(expectShasums));\n          });\n          return _downloadShasums.apply(this, arguments);\n        }\n        function downloadNodeLib() {\n          return _downloadNodeLib.apply(this, arguments);\n        } // downloadNodeLib()\n        function _downloadNodeLib() {\n          _downloadNodeLib = _asyncToGenerator(function* () {\n            log.verbose('on Windows; need to download `' + release.name + '.lib`...');\n            const dir = path.resolve(tarExtractDir, arch);\n            const targetLibPath = path.resolve(dir, release.name + '.lib');\n            const {\n              libUrl,\n              libPath\n            } = release[arch];\n            const name = `${arch} ${release.name}.lib`;\n            log.verbose(name, 'dir', dir);\n            log.verbose(name, 'url', libUrl);\n            yield fs.promises.mkdir(dir, {\n              recursive: true\n            });\n            log.verbose('streaming', name, 'to:', targetLibPath);\n            const res = yield download(gyp, libUrl);\n\n            // Since only required node.lib is downloaded throw error if it is not fetched\n            if (res.status !== 200) {\n              throw new Error(`${res.status} status code downloading ${name}`);\n            }\n            return streamPipeline(res.body, new ShaSum((_, checksum) => {\n              contentShasums[libPath] = checksum;\n              log.verbose('content checksum', libPath, checksum);\n            }), fs.createWriteStream(targetLibPath));\n          });\n          return _downloadNodeLib.apply(this, arguments);\n        }\n      });\n      return _go.apply(this, arguments);\n    }\n    function valid(file) {\n      // header files\n      const extname = path.extname(file);\n      return extname === '.h' || extname === '.gypi';\n    }\n    function rollback(_x9) {\n      return _rollback.apply(this, arguments);\n    }\n    /**\n     * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n     * it drops the permissions before invoking any child processes (like\n     * node-gyp). So what happens is the \"nobody\" user doesn't have\n     * permission to create the dev dir. As a fallback, make the tmpdir() be\n     * the dev dir for this installation. This is not ideal, but at least\n     * the compilation will succeed...\n     */\n    function _rollback() {\n      _rollback = _asyncToGenerator(function* (err) {\n        log.warn('install', 'got an error, rolling back install');\n        // roll-back the install if anything went wrong\n        yield util.promisify(gyp.commands.remove)([release.versionDir]);\n        throw err;\n      });\n      return _rollback.apply(this, arguments);\n    }\n    function eaccesFallback(_x10) {\n      return _eaccesFallback.apply(this, arguments);\n    }\n    function _eaccesFallback() {\n      _eaccesFallback = _asyncToGenerator(function* (err) {\n        const noretry = '--node_gyp_internal_noretry';\n        if (argv.indexOf(noretry) !== -1) {\n          throw err;\n        }\n        const tmpdir = os.tmpdir();\n        gyp.devDir = path.resolve(tmpdir, '.node-gyp');\n        let userString = '';\n        try {\n          // os.userInfo can fail on some systems, it's not critical here\n          userString = ` (\"${os.userInfo().username}\")`;\n        } catch (e) {}\n        log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir);\n        log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir);\n        if (process.cwd() === tmpdir) {\n          log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space');\n          gyp.todo.push({\n            name: 'remove',\n            args: argv\n          });\n        }\n        return util.promisify(gyp.commands.install)([noretry].concat(argv));\n      });\n      return _eaccesFallback.apply(this, arguments);\n    }\n  });\n  return _install.apply(this, arguments);\n}\nclass ShaSum extends stream.Transform {\n  constructor(callback) {\n    super();\n    this._callback = callback;\n    this._digester = crypto.createHash('sha256');\n  }\n  _transform(chunk, _, callback) {\n    this._digester.update(chunk);\n    callback(null, chunk);\n  }\n  _flush(callback) {\n    this._callback(null, this._digester.digest('hex'));\n    callback();\n  }\n}\nfunction download(_x4, _x5) {\n  return _download.apply(this, arguments);\n}\nfunction _download() {\n  _download = _asyncToGenerator(function* (gyp, url) {\n    log.http('GET', url);\n    const requestOpts = {\n      headers: {\n        'User-Agent': `node-gyp v${gyp.version} (node ${process.version})`,\n        Connection: 'keep-alive'\n      },\n      proxy: gyp.opts.proxy,\n      noProxy: gyp.opts.noproxy\n    };\n    const cafile = gyp.opts.cafile;\n    if (cafile) {\n      requestOpts.ca = yield readCAFile(cafile);\n    }\n    const res = yield fetch(url, requestOpts);\n    log.http(res.status, res.url);\n    return res;\n  });\n  return _download.apply(this, arguments);\n}\nfunction readCAFile(_x6) {\n  return _readCAFile.apply(this, arguments);\n}\nfunction _readCAFile() {\n  _readCAFile = _asyncToGenerator(function* (filename) {\n    // The CA file can contain multiple certificates so split on certificate\n    // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n    const ca = yield fs.promises.readFile(filename, 'utf8');\n    const re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g;\n    return ca.match(re);\n  });\n  return _readCAFile.apply(this, arguments);\n}\nmodule.exports = function (gyp, argv, callback) {\n  install(fs, gyp, argv).then(callback.bind(undefined, null), callback);\n};\nmodule.exports.test = {\n  download,\n  install,\n  readCAFile\n};\nmodule.exports.usage = 'Install node development files for the specified node version.';","map":{"version":3,"names":["_asyncToGenerator","require","default","fs","os","backOff","rm","tar","path","util","stream","crypto","log","semver","fetch","processRelease","win","process","platform","streamPipeline","promisify","pipeline","install","_x","_x2","_x3","_install","apply","arguments","gyp","argv","release","version","arch","opts","target_arch","shouldDownloadTarball","verbose","Error","lt","prerelease","nodedir","versionDir","devDir","resolve","ensure","promises","stat","err","code","go","rollback","eaccesFallback","installVersionFile","installVersion","ver","readFile","parseInt","package","nodeLibPath","copyDirectory","_x7","_x8","_copyDirectory","src","dest","mkdir","recursive","entries","readdir","withFileTypes","entry","isDirectory","join","name","isFile","copyFile","_go","created","tarPath","tarball","extractErrors","extractCount","contentShasums","expectShasums","isValid","valid","silly","onwarn","message","error","tarExtractDir","mkdtemp","tmpdir","extract","file","strip","filter","cwd","res","download","tarballUrl","status","body","ShaSum","_","checksum","filename","basename","trim","installVersionPath","Promise","all","downloadNodeLib","writeFile","downloadShasums","JSON","stringify","k","warn","_downloadShasums","shasumsUrl","line","text","split","items","length","replace","_downloadNodeLib","dir","targetLibPath","libUrl","libPath","createWriteStream","extname","_x9","_rollback","commands","remove","_x10","_eaccesFallback","noretry","indexOf","userString","userInfo","username","e","todo","push","args","concat","Transform","constructor","callback","_callback","_digester","createHash","_transform","chunk","update","_flush","digest","_x4","_x5","_download","url","http","requestOpts","headers","Connection","proxy","noProxy","noproxy","cafile","ca","readCAFile","_x6","_readCAFile","re","match","module","exports","then","bind","undefined","test","usage"],"sources":["C:/Users/vm200325d/Documents/faks/pia/pia_projekat/frontend/node_modules/node-gyp/lib/install.js"],"sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst os = require('os')\nconst { backOff } = require('exponential-backoff')\nconst rm = require('rimraf')\nconst tar = require('tar')\nconst path = require('path')\nconst util = require('util')\nconst stream = require('stream')\nconst crypto = require('crypto')\nconst log = require('npmlog')\nconst semver = require('semver')\nconst fetch = require('make-fetch-happen')\nconst processRelease = require('./process-release')\nconst win = process.platform === 'win32'\nconst streamPipeline = util.promisify(stream.pipeline)\n\n/**\n * @param {typeof import('graceful-fs')} fs\n */\n\nasync function install (fs, gyp, argv) {\n  const release = processRelease(argv, gyp, process.version, process.release)\n  // Detecting target_arch based on logic from create-cnfig-gyp.js. Used on Windows only.\n  const arch = win ? (gyp.opts.target_arch || gyp.opts.arch || process.arch || 'ia32') : ''\n  // Used to prevent downloading tarball if only new node.lib is required on Windows.\n  let shouldDownloadTarball = true\n\n  // Determine which node dev files version we are installing\n  log.verbose('install', 'input version string %j', release.version)\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    throw new Error('Invalid version number: ' + release.version)\n  }\n\n  if (semver.lt(release.version, '0.8.0')) {\n    throw new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version)\n  }\n\n  // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version)\n    if (!gyp.opts.nodedir) {\n      throw new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead')\n    }\n    log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir)\n    return\n  }\n\n  // flatten version into String\n  log.verbose('install', 'installing version: %s', release.versionDir)\n\n  // the directory where the dev files will be installed\n  const devDir = path.resolve(gyp.devDir, release.versionDir)\n\n  // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed')\n    try {\n      await fs.promises.stat(devDir)\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        log.verbose('install', 'version not already installed, continuing with install', release.version)\n        try {\n          return await go()\n        } catch (err) {\n          return rollback(err)\n        }\n      } else if (err.code === 'EACCES') {\n        return eaccesFallback(err)\n      }\n      throw err\n    }\n    log.verbose('install', 'version is already installed, need to check \"installVersion\"')\n    const installVersionFile = path.resolve(devDir, 'installVersion')\n    let installVersion = 0\n    try {\n      const ver = await fs.promises.readFile(installVersionFile, 'ascii')\n      installVersion = parseInt(ver, 10) || 0\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        throw err\n      }\n    }\n    log.verbose('got \"installVersion\"', installVersion)\n    log.verbose('needs \"installVersion\"', gyp.package.installVersion)\n    if (installVersion < gyp.package.installVersion) {\n      log.verbose('install', 'version is no good; reinstalling')\n      try {\n        return await go()\n      } catch (err) {\n        return rollback(err)\n      }\n    }\n    log.verbose('install', 'version is good')\n    if (win) {\n      log.verbose('on Windows; need to check node.lib')\n      const nodeLibPath = path.resolve(devDir, arch, 'node.lib')\n      try {\n        await fs.promises.stat(nodeLibPath)\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          log.verbose('install', `version not already installed for ${arch}, continuing with install`, release.version)\n          try {\n            shouldDownloadTarball = false\n            return await go()\n          } catch (err) {\n            return rollback(err)\n          }\n        } else if (err.code === 'EACCES') {\n          return eaccesFallback(err)\n        }\n        throw err\n      }\n    }\n  } else {\n    try {\n      return await go()\n    } catch (err) {\n      return rollback(err)\n    }\n  }\n\n  async function copyDirectory (src, dest) {\n    try {\n      await fs.promises.stat(src)\n    } catch {\n      throw new Error(`Missing source directory for copy: ${src}`)\n    }\n    await fs.promises.mkdir(dest, { recursive: true })\n    const entries = await fs.promises.readdir(src, { withFileTypes: true })\n    for (const entry of entries) {\n      if (entry.isDirectory()) {\n        await copyDirectory(path.join(src, entry.name), path.join(dest, entry.name))\n      } else if (entry.isFile()) {\n        // with parallel installs, copying files may cause file errors on\n        // Windows so use an exponential backoff to resolve collisions\n        await backOff(async () => {\n          try {\n            await fs.promises.copyFile(path.join(src, entry.name), path.join(dest, entry.name))\n          } catch (err) {\n            // if ensure, check if file already exists and that's good enough\n            if (gyp.opts.ensure && err.code === 'EBUSY') {\n              try {\n                await fs.promises.stat(path.join(dest, entry.name))\n                return\n              } catch {}\n            }\n            throw err\n          }\n        })\n      } else {\n        throw new Error('Unexpected file directory entry type')\n      }\n    }\n  }\n\n  async function go () {\n    log.verbose('ensuring devDir is created', devDir)\n\n    // first create the dir for the node dev files\n    try {\n      const created = await fs.promises.mkdir(devDir, { recursive: true })\n\n      if (created) {\n        log.verbose('created devDir', created)\n      }\n    } catch (err) {\n      if (err.code === 'EACCES') {\n        return eaccesFallback(err)\n      }\n\n      throw err\n    }\n\n    // now download the node tarball\n    const tarPath = gyp.opts.tarball\n    let extractErrors = false\n    let extractCount = 0\n    const contentShasums = {}\n    const expectShasums = {}\n\n    // checks if a file to be extracted from the tarball is valid.\n    // only .h header files and the gyp files get extracted\n    function isValid (path) {\n      const isValid = valid(path)\n      if (isValid) {\n        log.verbose('extracted file from tarball', path)\n        extractCount++\n      } else {\n        // invalid\n        log.silly('ignoring from tarball', path)\n      }\n      return isValid\n    }\n\n    function onwarn (code, message) {\n      extractErrors = true\n      log.error('error while extracting tarball', code, message)\n    }\n\n    // download the tarball and extract!\n    // Ommited on Windows if only new node.lib is required\n\n    // on Windows there can be file errors from tar if parallel installs\n    // are happening (not uncommon with multiple native modules) so\n    // extract the tarball to a temp directory first and then copy over\n    const tarExtractDir = win ? await fs.promises.mkdtemp(path.join(os.tmpdir(), 'node-gyp-tmp-')) : devDir\n\n    try {\n      if (shouldDownloadTarball) {\n        if (tarPath) {\n          await tar.extract({\n            file: tarPath,\n            strip: 1,\n            filter: isValid,\n            onwarn,\n            cwd: tarExtractDir\n          })\n        } else {\n          try {\n            const res = await download(gyp, release.tarballUrl)\n\n            if (res.status !== 200) {\n              throw new Error(`${res.status} response downloading ${release.tarballUrl}`)\n            }\n\n            await streamPipeline(\n              res.body,\n              // content checksum\n              new ShaSum((_, checksum) => {\n                const filename = path.basename(release.tarballUrl).trim()\n                contentShasums[filename] = checksum\n                log.verbose('content checksum', filename, checksum)\n              }),\n              tar.extract({\n                strip: 1,\n                cwd: tarExtractDir,\n                filter: isValid,\n                onwarn\n              })\n            )\n          } catch (err) {\n          // something went wrong downloading the tarball?\n            if (err.code === 'ENOTFOUND') {\n              throw new Error('This is most likely not a problem with node-gyp or the package itself and\\n' +\n              'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' +\n              'network settings.')\n            }\n            throw err\n          }\n        }\n\n        // invoked after the tarball has finished being extracted\n        if (extractErrors || extractCount === 0) {\n          throw new Error('There was a fatal problem while downloading/extracting the tarball')\n        }\n\n        log.verbose('tarball', 'done parsing tarball')\n      }\n\n      const installVersionPath = path.resolve(tarExtractDir, 'installVersion')\n      await Promise.all([\n      // need to download node.lib\n        ...(win ? [downloadNodeLib()] : []),\n        // write the \"installVersion\" file\n        fs.promises.writeFile(installVersionPath, gyp.package.installVersion + '\\n'),\n        // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n        ...(!tarPath || win ? [downloadShasums()] : [])\n      ])\n\n      log.verbose('download contents checksum', JSON.stringify(contentShasums))\n      // check content shasums\n      for (const k in contentShasums) {\n        log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k])\n        if (contentShasums[k] !== expectShasums[k]) {\n          throw new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k])\n        }\n      }\n\n      // copy over the files from the temp tarball extract directory to devDir\n      if (tarExtractDir !== devDir) {\n        await copyDirectory(tarExtractDir, devDir)\n      }\n    } finally {\n      if (tarExtractDir !== devDir) {\n        try {\n          // try to cleanup temp dir\n          await util.promisify(rm)(tarExtractDir)\n        } catch {\n          log.warn('failed to clean up temp tarball extract directory')\n        }\n      }\n    }\n\n    async function downloadShasums () {\n      log.verbose('check download content checksum, need to download `SHASUMS256.txt`...')\n      log.verbose('checksum url', release.shasumsUrl)\n\n      const res = await download(gyp, release.shasumsUrl)\n\n      if (res.status !== 200) {\n        throw new Error(`${res.status}  status code downloading checksum`)\n      }\n\n      for (const line of (await res.text()).trim().split('\\n')) {\n        const items = line.trim().split(/\\s+/)\n        if (items.length !== 2) {\n          return\n        }\n\n        // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n        const name = items[1].replace(/^\\.\\//, '')\n        expectShasums[name] = items[0]\n      }\n\n      log.verbose('checksum data', JSON.stringify(expectShasums))\n    }\n\n    async function downloadNodeLib () {\n      log.verbose('on Windows; need to download `' + release.name + '.lib`...')\n      const dir = path.resolve(tarExtractDir, arch)\n      const targetLibPath = path.resolve(dir, release.name + '.lib')\n      const { libUrl, libPath } = release[arch]\n      const name = `${arch} ${release.name}.lib`\n      log.verbose(name, 'dir', dir)\n      log.verbose(name, 'url', libUrl)\n\n      await fs.promises.mkdir(dir, { recursive: true })\n      log.verbose('streaming', name, 'to:', targetLibPath)\n\n      const res = await download(gyp, libUrl)\n\n      // Since only required node.lib is downloaded throw error if it is not fetched\n      if (res.status !== 200) {\n        throw new Error(`${res.status} status code downloading ${name}`)\n      }\n\n      return streamPipeline(\n        res.body,\n        new ShaSum((_, checksum) => {\n          contentShasums[libPath] = checksum\n          log.verbose('content checksum', libPath, checksum)\n        }),\n        fs.createWriteStream(targetLibPath)\n      )\n    } // downloadNodeLib()\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n  function valid (file) {\n    // header files\n    const extname = path.extname(file)\n    return extname === '.h' || extname === '.gypi'\n  }\n\n  async function rollback (err) {\n    log.warn('install', 'got an error, rolling back install')\n    // roll-back the install if anything went wrong\n    await util.promisify(gyp.commands.remove)([release.versionDir])\n    throw err\n  }\n\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n  async function eaccesFallback (err) {\n    const noretry = '--node_gyp_internal_noretry'\n    if (argv.indexOf(noretry) !== -1) {\n      throw err\n    }\n    const tmpdir = os.tmpdir()\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp')\n    let userString = ''\n    try {\n      // os.userInfo can fail on some systems, it's not critical here\n      userString = ` (\"${os.userInfo().username}\")`\n    } catch (e) {}\n    log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir)\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir)\n    if (process.cwd() === tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space')\n      gyp.todo.push({ name: 'remove', args: argv })\n    }\n    return util.promisify(gyp.commands.install)([noretry].concat(argv))\n  }\n}\n\nclass ShaSum extends stream.Transform {\n  constructor (callback) {\n    super()\n    this._callback = callback\n    this._digester = crypto.createHash('sha256')\n  }\n\n  _transform (chunk, _, callback) {\n    this._digester.update(chunk)\n    callback(null, chunk)\n  }\n\n  _flush (callback) {\n    this._callback(null, this._digester.digest('hex'))\n    callback()\n  }\n}\n\nasync function download (gyp, url) {\n  log.http('GET', url)\n\n  const requestOpts = {\n    headers: {\n      'User-Agent': `node-gyp v${gyp.version} (node ${process.version})`,\n      Connection: 'keep-alive'\n    },\n    proxy: gyp.opts.proxy,\n    noProxy: gyp.opts.noproxy\n  }\n\n  const cafile = gyp.opts.cafile\n  if (cafile) {\n    requestOpts.ca = await readCAFile(cafile)\n  }\n\n  const res = await fetch(url, requestOpts)\n  log.http(res.status, res.url)\n\n  return res\n}\n\nasync function readCAFile (filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  const ca = await fs.promises.readFile(filename, 'utf8')\n  const re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g\n  return ca.match(re)\n}\n\nmodule.exports = function (gyp, argv, callback) {\n  install(fs, gyp, argv).then(callback.bind(undefined, null), callback)\n}\nmodule.exports.test = {\n  download,\n  install,\n  readCAFile\n}\nmodule.exports.usage = 'Install node development files for the specified node version.'\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}